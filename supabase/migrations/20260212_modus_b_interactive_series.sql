-- =============================================================================
-- Modus B: Interactive Series ("Mitgestalten") â€“ Phase A: DB Migrations
-- =============================================================================
-- Children choose from 3 options at the end of each episode (1-4).
-- Episode 5 is the finale (no options).
-- Modus B is a separate series type with its own pricing tier.
-- =============================================================================

-- A.1: New table: story_branches
-- Stores the 3 LLM-generated options per episode + the child's choice
CREATE TABLE IF NOT EXISTS story_branches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  story_id UUID NOT NULL REFERENCES stories(id) ON DELETE CASCADE,
  series_id UUID NOT NULL,
  episode_number INTEGER NOT NULL CHECK (episode_number BETWEEN 1 AND 4),
  
  -- The 3 options generated by the LLM
  -- Structure:
  -- [
  --   {
  --     "option_id": "A",
  --     "title": "Den geheimen Tunnel erkunden",
  --     "preview": "Mikel entdeckt hinter dem Wasserfall einen dunklen Gang...",
  --     "direction": "brave",
  --     "image_hint": "A dark tunnel behind a waterfall with faint glowing crystals"
  --   },
  --   { "option_id": "B", ... },
  --   { "option_id": "C", ... }
  -- ]
  options JSONB NOT NULL,
  
  -- What the child chose
  chosen_option_id TEXT CHECK (chosen_option_id IN ('A', 'B', 'C')),
  chosen_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Index for fast loading by series + episode
CREATE INDEX IF NOT EXISTS idx_story_branches_series 
  ON story_branches(series_id, episode_number);

-- A.2: Extend stories table
-- series_mode: NULL = single story, 'normal' = Modus A (linear), 'interactive' = Modus B
ALTER TABLE stories ADD COLUMN IF NOT EXISTS
  series_mode TEXT CHECK (series_mode IN ('normal', 'interactive'));

-- branch_chosen: The option title that led to this episode (for Ep2-5 context in prompts)
ALTER TABLE stories ADD COLUMN IF NOT EXISTS
  branch_chosen TEXT;

-- A.3: Subscription tiers table
-- Pricing & feature gating for series types
CREATE TABLE IF NOT EXISTS subscription_tiers (
  id TEXT PRIMARY KEY,           -- 'free', 'basic', 'premium'
  name TEXT NOT NULL,
  price_monthly DECIMAL(5,2),
  stories_per_week INTEGER,      -- Max stories per week
  series_enabled BOOLEAN DEFAULT false,
  series_interactive_enabled BOOLEAN DEFAULT false,
  max_episodes_per_series INTEGER DEFAULT 5,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Seed default tiers
INSERT INTO subscription_tiers (id, name, price_monthly, stories_per_week, series_enabled, series_interactive_enabled, max_episodes_per_series)
VALUES
  ('free',    'Kostenlos',     0.00,  2, false, false, 0),
  ('basic',   'Entdecker',     4.99, 20, true,  false, 5),
  ('premium', 'Mitgestalter',  9.99, 50, true,  true,  5)
ON CONFLICT (id) DO NOTHING;

-- RLS policies for story_branches (same pattern as stories)
ALTER TABLE story_branches ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read their own story branches"
  ON story_branches FOR SELECT
  USING (true);

CREATE POLICY "Users can insert story branches"
  ON story_branches FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Users can update their own story branches"
  ON story_branches FOR UPDATE
  USING (true);

-- RLS for subscription_tiers (read-only for all, admin manages via SQL)
ALTER TABLE subscription_tiers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can read subscription tiers"
  ON subscription_tiers FOR SELECT
  USING (true);
